using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;

public delegate void BodyEmptyCallback(LiquidBody liquidBody);
public class TileLayerManager : MonoBehaviour
{
    private Dictionary<Vector3Int, TileData> positionsToTileData = new Dictionary<Vector3Int, TileData>();
    private List<LiquidBody> liquidBodies = new List<LiquidBody>();
    private List<LiquidBody> previewBodies = new List<LiquidBody>();
    private List<Vector3Int> ChangedTiles = new List<Vector3Int>();
    public bool holdsContent;
    private BodyEmptyCallback bodyEmptyCallback;
    private HashSet<Vector3Int> removedTiles = new HashSet<Vector3Int>();
    void Awake()
    {
        this.bodyEmptyCallback = OnLiquidBodyEmpty;
        //TODO parse and initialize liquid bodies
    }

    public void UpdateContents(Vector3Int tilePosition, float[] contents)
    {
        if (!this.holdsContent)
        {
            Debug.LogError("Tile at this location does not hold contents");
            return;
        }
        this.positionsToTileData[tilePosition].currentLiquidBody.contents = contents;
        // TODO Update color
    }
    public void AddTile(Vector3Int cellPosition, GameTile tile, float[] contents)
    {
        this.positionsToTileData[cellPosition].PreviewReplacement(tile, MergeLiquidBodies(cellPosition, tile, contents)); // Add body information to tile
        // TODO update color
    }
    public void RemoveTile(Vector3Int cellPosition)
    {
        this.positionsToTileData[cellPosition].PreviewReplacement(null, null);
        this.removedTiles.Add(cellPosition);
        DivideLiquidBody(cellPosition);
    }
    /// <summary>
    /// Merge Current Tile to existing liquid bodies
    /// </summary>
    /// <param name="cellPosition"></param>
    /// <param name="tile"></param>
    /// <param name="contents"></param>
    /// <returns></returns>
    private LiquidBody MergeLiquidBodies(Vector3Int cellPosition, GameTile tile, float[] contents)
    {
        if (!this.holdsContent)
        {
            return null;
        }
        HashSet<LiquidBody> neighborLiquidBodies = new HashSet<LiquidBody>();
        foreach (Vector3Int neighborCell in FourNeighborTileCellPositions(cellPosition))
        {
            if (positionsToTileData[neighborCell].currentTile == tile)
            {
                neighborLiquidBodies.Add(positionsToTileData[neighborCell].currentLiquidBody);
            }
        }
        neighborLiquidBodies.Distinct().ToList();
        switch (neighborLiquidBodies.Count)
        {
            case 0: // Create new body
                HashSet<Vector3Int> newBodyTiles = new HashSet<Vector3Int>();
                LiquidBody newBody = new LiquidBody(newBodyTiles, contents, bodyEmptyCallback);
                previewBodies.Add(newBody);
                return newBody;
            case 1: // Extend the new one drawn, or extend existing body
                List<LiquidBody> liquidBodyL = liquidBodies.ToList();
                if (liquidBodyL[0].bodyID == 0) // Preview Liquid Body, newly placed tile
                {
                    liquidBodyL[0].AddTile(cellPosition);
                    return liquidBodyL[0];
                }
                LiquidBody extendedBody = new LiquidBody(liquidBodyL[0], cellPosition);
                this.previewBodies.Add(extendedBody);
                return extendedBody;
            default: // Merge Multiple bodies, including new bodies generated by the placement
                LiquidBody mergedBody = new LiquidBody(neighborLiquidBodies, bodyEmptyCallback);
                mergedBody.AddTile(cellPosition);
                this.previewBodies.Add(mergedBody);
                foreach (LiquidBody liquidBody in mergedBody.referencedBodies)
                {
                    if (liquidBody.bodyID == 0)
                    {
                        previewBodies.Remove(liquidBody);
                    }
                }
                UpdatePreviewLiquidBody(mergedBody);
                return mergedBody;
        }
    }
    private void DivideLiquidBody(Vector3Int cellPosition)
    {
        HashSet<Vector3Int> remainingTiles = new HashSet<Vector3Int>();
        remainingTiles.UnionWith(positionsToTileData[cellPosition].currentLiquidBody.tiles);
        remainingTiles.ExceptWith(removedTiles);
        int[] connections = new int[8] { 0, 0, 0, 0, 0, 0, 0, 0 };
        List<Vector3Int> fourNeighbor = FourNeighborTileCellPositions(cellPosition);
        int numNeighbor = 0;
        for (int i = 0; i < 4; i++)
        {
            if (remainingTiles.Contains(fourNeighbor[i]))
            {
                connections[i * 2] = 1;
                numNeighbor++;
            }
        }
        List<Vector3Int> fourDiagonal = FourDiagonalTileCellPositions(cellPosition);
        for (int i = 0; i < 4; i++)
        {
            if (remainingTiles.Contains(fourDiagonal[i]))
            {
                connections[i * 2 + 1] = 1;
            }
        }
        bool continueous = false;
        for (int i = 0; i < 8; i += 2)
        {
            if (connections[i] == 1)
            {
                int numFound = 1;
                for (int j = 1; j < 7; j += 2)
                {
                    if (connections[LoopIteration(i + j, 7)] == 1 && connections[LoopIteration(i + j + 1, 7)] == 1)
                    {
                        numFound++;
                        if (numFound == numNeighbor)
                        {
                            continueous = true;
                            break;
                        }
                    }
                }
            }
        }
        if (!continueous)
        {
            
            for (int i = 0; i < 4; i++)
            {
                if (remainingTiles.Contains(fourNeighbor[i]))
                {
                    connections[i * 2] = 1;
                    numNeighbor++;
                }
            }
        }
    }
    private void UpdatePreviewLiquidBody(LiquidBody liquidBody)
    {
        foreach (Vector3Int tileCellPosition in liquidBody.tiles)
        {
            this.positionsToTileData[tileCellPosition].PreviewLiquidBody(liquidBody);
        }
    }
    private int LoopIteration(int current, int oneOverMax)
    {
        return (current - oneOverMax);
    }
    private List<Vector3Int> FourNeighborTileCellPositions(Vector3Int cellPosition)
    {
        List<Vector3Int> result = new List<Vector3Int>();
        result.Add(new Vector3Int(cellPosition.x, cellPosition.y + 1, cellPosition.z));
        result.Add(new Vector3Int(cellPosition.x + 1, cellPosition.y, cellPosition.z));
        result.Add(new Vector3Int(cellPosition.x, cellPosition.y - 1, cellPosition.z));
        result.Add(new Vector3Int(cellPosition.x - 1, cellPosition.y, cellPosition.z));
        return result;
    }
    private List<Vector3Int> FourDiagonalTileCellPositions(Vector3Int cellPosition)
    {
        List<Vector3Int> result = new List<Vector3Int>();
        result.Add(new Vector3Int(cellPosition.x + 1, cellPosition.y + 1, cellPosition.z));
        result.Add(new Vector3Int(cellPosition.x + 1, cellPosition.y - 1, cellPosition.z));
        result.Add(new Vector3Int(cellPosition.x - 1, cellPosition.y + 1, cellPosition.z));
        result.Add(new Vector3Int(cellPosition.x - 1, cellPosition.y - 1, cellPosition.z));
        return result;
    }
    private void OnLiquidBodyEmpty(LiquidBody liquidBody)
    {
        liquidBodies.Remove(liquidBody);
    }
}
